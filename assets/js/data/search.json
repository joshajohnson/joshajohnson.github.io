[ { "title": "BSides Canberra 2023", "url": "/bsidescbr23/", "categories": "", "tags": "", "date": "2023-08-31 21:00:00 +1000", "snippet": "Hello! Welcome to the landing page for BSides Canberra 2023. Below are the links you’ve been searching for.Designing a Badge Add-on in KiCadSAO Connector ModificationWe unfortunately ran out of con...", "content": "Hello! Welcome to the landing page for BSides Canberra 2023. Below are the links you’ve been searching for.Designing a Badge Add-on in KiCadSAO Connector ModificationWe unfortunately ran out of connectors at the event, fortunately standard headers can be modified to suit. Cut two pins off and install as per the below photo.Digital Explorer Board" }, { "title": "BSidesCBR23 Badge Add-on Workshop", "url": "/bsidescbr23-workshop/", "categories": "", "tags": "", "date": "2023-08-31 20:30:00 +1000", "snippet": "IntroductionThe goal of today’s workshop is to design and assemble a printed circuit board (PCB) which takes the form of a magpie with a blinking eye. Once assembled, the add-on will plug into your...", "content": "IntroductionThe goal of today’s workshop is to design and assemble a printed circuit board (PCB) which takes the form of a magpie with a blinking eye. Once assembled, the add-on will plug into your badge and scare everyone within swooping distance whilst reminding them that Birds Aren’t Real.By the end of the workshop you’ll have learnt how to design a schematic and layout a PCB using KiCad, along with how to solder through hole and surface mount components.Let’s Begin!Before we dive into designing the PCB, we need to pick a CAD tool to use. Whilst there are online tools such as Easy EDA, they are limited in capability due to running in a browser and if you continue to design PCBs after this workshop may run into limitations. As such we will be using KiCad, an extremely powerful and open source EDA tool, which will handle whatever you can throw at it.If you have not already installed KiCad, please download it from here. We will be using version 7 in this workshop, if you have an earlier version please update to V7 or proceed at your own peril!You will also need to download the library I have made for this workshop, as it contains custom symbols and most importantly the artwork to make our badge look like a magpie.KiCad Project SetupPrior to starting the design, we need to make a new KiCad project and add the above downloaded library so we can use the symbols and footprints. Open KiCad. File -&gt; New Project. Give your project a fun name and a place to live. Extract the library files to within your newly created project folder. Preferences -&gt; Manage Symbol Libraries Change tab to “Project Specific Libraries” Click on the “folder” button, and select the sao-workshop.kicad_sym file you downloaded earlier. Preferences -&gt; Manage Footprint Libraries Change tab to “Project Specific Libraries” Click on the “folder” button, and select the sao-workshop.pretty folder you downloaded earlier.With the project setup and libraries added, are now ready to draw up the schematic.Schematic CaptureSchematic capture is the first step of the PCB design process, and involves drawing the circuit we want to design and defining what pins connect to each other. During this step we don’t have to follow the laws of physics which allows us to rearrange pins, use net labels to connect signals, and split the design across multiple sheets on a big design to draw the design in a way which is easy to read and understand.KiCad Schematic Hotkeys Reference Shortcut Function A Place (add) symbol E Edit symbol M Move symbol R Rotate symbol Functional DescriptionFor this workshop we’ll be designing an astable 555 timer, which is a fancy way of toggling a pin (and in turn a LED) on and off forever. A simplified version of the circuit we will be designing is shown below.By varying the values of R1, R2, and C, we can adjust the frequency (how fast the output toggles from high to low) and the duty cycle (percentage of time the pin is high in a given period). The maths to determine the components values for a 50% duty cycle is below.f = sqrt(2)/(C1(R1 + 2R2)) = 1.4/(1u(1K + 2*470K)) = 1.5 HzDrawing the Schematic Open the schematic editor. Press A to add a new part, and select the 555 timer from the sao_workshop library. Press A again and add resistors (search R), capacitor (search C) and LED (search LED) arrange as shown below. To rotate the symbol, press R whilst dragging the symbol. Double click on each symbol and update the component values as shown below. The “K” stands for KiloOhms (1000 Ohms), and the ”u” for microfarads (0.000001 Farads). With the components placed, we can add the power and ground symbols by pressing A then searching for +3V3 and GND. “+3V3” and “GND” are magic symbols that put the badge voltage and ground anywhere on the board, and means you don’t have to run a wire to connect power/ground to every point on the schematic. Finally, with all these components placed, use the wire W tool to connect all the pins as shown below.At this stage, we have the 555 timer all wired up, however we don’t have a way of supplying it with power. Your bPod has a SAO header on it which supplies the required 3V3 and GND connections, so let’s use that. Add the SAO connector by opening the choose symbol (A) screen and searching SAO. Then add +3V3 and GND symbols as shown below.With this done, we’ve got all the electrical components required to blink a LED. However we don’t yet have the board in the shape of a magpie. As “magpie” isn’t a schematic symbol, we’ll add a dummy component which we will later assign to be the footprint of our magpie. Add a Housing to the schematic and rename it to Outline.This concludes placing parts in the schematic, and we can start setting things up for layout.Annotation, Electrical Rules Check, Footprint AssociationCurrently our symbols are abstract objects that don’t have unique IDs or footprints associated to them, two things which are required to lay out the PCB. Annotate the schematic (assign unique numbers to each component) using the below button.Once this is complete, you should have unique numbers on each component on the PCB.We can now run Electrical Rules Check (ERC). ERC is a basic sanity check designed to find obvious issues such as pins which are not connected, two inputs connected to each other, or no power being provided to an IC, and it’s a good rule to not start PCB layout until your schematic is clear of ERC errors. Run ERC from the menu shown below, and you should get 8 errors. Five of these errors are due to unconnected pins, and can be fixed by placing no-connection directives Q on the unconnected pins to tell KiCad they’ve been left disconnected by design.Run ERC again, and you’ll see two remaining errors for “Input Power pin not driven by any Output Power pins”. This is KiCad complaining because the 555 timer has power pins, but we haven’t told it the SAO header provides power, so it thinks the IC won’t get any power to turn on. This issue can be fixed by placing PWR_FLAG on the 3V3 and GND nets to tell KiCad these nets are being driven by a power source.With this last step, ERC shouldn’t have any errors (it’ll still have two warnings, but they’ll be ignored for this workshop), and we can continue to footprint association.A given part (e.g. 1K resistor) can come in many different physical form factors, from large through hole power resistors, to tiny surface mount resistors found in modern electronics. To keep the number of components in the KiCad library down, they don’t make different symbols for each and every possible permutation, but instead get the designer to specify the footprint before moving onto PCB design. Using the footprint association tool, assign the correct footprints to the symbols as shown below. Note the sao-workshop:magpie_outline library may be located at the bottom of the list, not in alphabetical order.With the footprint association complete, we are ready to continue onto PCB layout!PCB LayoutDuring schematic capture we told KiCad how we wanted to connect the components together. In layout, KiCad uses this information to assist us to make the connections whilst ensuring we follow the rules of physics this time. It’s like a big game of connect the dots!KiCad PCB Hotkeys Reference Shortcut Function M Move footprint X Route trace V (whilst routing) Place via CTRL + SHIFT + V (not routing) Place via R Rotate footprint F Flip footprint H Dim inactive layers ALT + 3 3D Viewer PCB LayersA PCB consists of a number of layers of varying materials, and KiCad has a layer in the PCB layout tool that corresponds to each. The below are the ones we will be using in this workshop, and you can move between layers by clicking on it’s name in the PCB editor. Layer KiCad Colour Function Top Silkscreen F.Silkscreen Yellow Markings on top of PCB Top Soldermask F.Mask Purple Negative outline of where copper should be exposed Top Copper F.Cu Red Copper on top of PCB FR4 Core N/A N/A Mechanical stiffness / holds PCB together Bottom Copper B.Cu Blue Copper on bottom of PCB Bottom Soldermask B.Mask Green Negative outline of where copper should be exposed Bottom Silkscreen B.Silkscreen Peach Markings on bottom of PCB N/A Edge.Cuts White Defines outline of PCB The below image from EMSL shows a cross section of a two layer PCB highlighting the above features, along with a cross section of a plated through hole.Import SchematicBefore we can lay out the PCB, we need to import the schematic we defined in the earlier steps. Open the PCB editor (PCBNew). Update PCB with changes from board editor. Select “Update PCB” and check that you don’t have any errors. You should now be able to left click and place all the components on the PCB.Placing ComponentsWith the parts in the PCB editor, we need to place them on the PCB. This design will have all components other than the LED on the back of the board, so select them and press F to flip to the back. You’ll see their colour turn from red to blue.We can now place the LED and connector in their locations, as they are fixed due to the mechanical design. First adjust the grid size to 0.1mm, as the 2.54mm KiCad ships with by default is too large. Select the part, press M and move to the below locations. Press R whilst moving to rotate. You can also look at the design in the 3D viewer ALT + 3, as this can help determine if the mechanical parts are in the correct location.It’s now time to place all the electrical components on the PCB. Ideal component placement is a talk all in itself, but the primary goal is to have the fewest number of connection lines (typically called rats nests for some reason…) crossing as possible, as this will ease our routing step. I encourage you to try this step yourself before scrolling down to copy my solution. Select a part and press M to move it. With the part selected, press R to rotate it. Place the part on the PCB. Repeat for all other components. Keep going in an infinite loop until you are happy that there are as few connection lines as possible crossing. You may want to turn off the F.Silkscreen (click the eye next to the name) so you can see the parts being placed on the PCB easier.Poor component placement (lots of crossing lines).Good component placement (minimal crossing lines).Defining Board OutlineNormally once you’ve placed the components on the PCB it’s time to define the board outline. However due to the magpie outline being provided this step isn’t needed today, but for future boards where the outline isn’t provided it can be done as below. Select the layer “Edge.Cuts”. Grab the line tool. Draw an enclosed shape. You can use the arc tool to give the PCB rounded corners.Routing the PCBRouting a PCB involves using copper to connect all of the required nets together so it functions correctly. Most PCBs will have a net called ground which most components connect to, so it’s common to dedicate an entire layer of the PCB to ground so make routing easier. Select F.Cu, click the “Add a filled zone” tool. Click anywhere on the PCB to open the menu. When you get to the popup screen, select both F.Cu and B.Cu, and net as GND. Draw a box around the outside of the board, it does not need to follow the outline. Press B to fill all zones, and you’ll see the ground fills be poured and some of the connection lines go away as they are being connected by the plane.It’s now time to route individual traces to get rid of the remaining connection lines. Hover cursor over a pad until it snaps. Press X to begin routing. Move your cursor around to guide the trace, and left click to freeze the trace in place. Once you reach the other pad, wait for the cursor to snap to the pad and click to finish. Press B to repour the zone, which will move the pour away from the newly routed traces.At this point you might find that it’s easy to route all but one of the traces. This is where we can use a via to change layers and make routing the impossible possible. Begin routing on the bottom layer as you were doing. Press V to drop a via and move to the top layer. Move to the other side of the trace, and press V again to place another via and return to the bottom copper. Connect to the pad, and press B to repour the copper fill.Design Rules CheckWhilst the PCB layout tool tries to prevent you from making mistakes, they always happen so it’s best practice to run Design Rule Checks (DRC) before ordering boards. Run DRC, and check there for errors. If there are errors, fix them and run DRC until they are all clear. Due to the artwork on the badge, it’s normal to get a warning about “Silkscreen clipped my solder mask” due to the location of the SAO connector.SilkscreenNow that DRC is clear, you are safe to order your PCBs knowing they’ll most likely work. However it’s also important for them to look nice, so let’s tidy up the silkscreen and add our name first. Press ALT + 3 to open the 3D viewer and look at the PCB. You’ll notice D1 is on the front of the PCB, which is undesirable. Close the 3D viewer, select F.Silkscreen, click on D1, and press F to flip it to the back of the PCB. We can now add our name and any text you’d like on the back of the board by selecting B.Silkscreen, and using the text tool. We can now move the newly created text and any of the reference designators around using M and R just like we did with the components. Use the 3D viewer ALT + 3 whilst doing this as it gives a much better idea of everything will look.Exporting Gerbers and Ordering PCBsNow that our PCB is complete, it’s time to generate the required files to order our boards! Using the Plot (not Print!) button, ensure all the layers we are using are selected, the plot format is Gerber, and plot the files to a folder of your choice.Keeping this window open, we also need to plot the drill files, as for historical reasons the gerbers do not contain the drill information. Select “Generate Drill Files”, check the settings are the same as the below image, and “Generate Drill File” to the same folder you picked before.Before sending these files off, we’ll check them in KiCad’s inbuilt gerber viewer to check everything looks good. KiCad Homepage -&gt; Gerber Viewer. “Open Autodetected files on new layer”. Select the gerbers and drill files exported earlier. Click on each layer to bring it to the foreground and check everything lines up / nothing looks unusual. Turning off layers to just look at the top / bottom of the board can help with this.Once you are happy with the gerbers, they can be zipped up and sent off to your PCB fabricator of choice to get manufactured.Don’t forget to order your components at this time, otherwise you won’t be able to assemble the boards once they arrive!PCB AssemblyOnce your PCBs and parts have arrived, it’s time to assemble the boards! As our board has both surface mount and through hole components, we’ll solder the surface mount components first, followed by the through hole parts.Surface Mount ComponentsRegardless of what SMD (surface mount device) part you are soldering, the process is the same: Tin one pad of the PCB. Grab the part with your tweezers. Melt the solder you just put down. Place the part in the now molten solder and remove your iron. Once the part has cooled down, let go of it. Solder any remaining pads.The below video shows this process. Solder R1 (1K), R2 (470K), and R3 (330R) using the above process. Rotation / polarity does not matter. Solder U1 (555), ensuring the bar is facing the 555 text. Tack one pin in place. Solder the remaining pins. Solder C1 (1u).With that, all the surface mount parts are done!Though Hole ComponentsThe LED is the next part to be soldered, and is polarised so rotation is important!There are two ways to orient the LED correctly: Line the flat side of the LED up with the flat side of the silkscreen. Line the long led of the LED up with the circular hole. Insert the LED, flip over the PCB, and bend the LEDs so the LED stays in place. Solder the LED. Trim the leads, ensuring you cut towards the table as the legs will go flying! Orient the IDC connector so the cutout is lined up with the arrow. Solder one pin of the IDC connector. Check the IDC connector is flush with the PCB. Solder the remaining pins (not shown). Finally, solder the mating connector to your badge just as you did with the IDC connector (not shown). Smoke TestWith all the soldering done, plug the add-on into your badge and enjoy the blinking LED!If the LED doesn’t blink, check the LED and 555 timer polarity, along with the solder joints.Caught the soldering bug and want to buy some equipment for use at home? I have a suggested list here.If you have any questions or feedback please let me know, otherwise thanks for attending the workshop and happy PCB designing!" }, { "title": "Digital Explorer Board", "url": "/digital-explorer-board/", "categories": "", "tags": "", "date": "2023-08-31 20:00:15 +1000", "snippet": "On your bPod, you’ll find a tools menu which provides a way to interface with a number of common embedded protocols. The digital explorer board in combination with a logic analyser provides a way t...", "content": "On your bPod, you’ll find a tools menu which provides a way to interface with a number of common embedded protocols. The digital explorer board in combination with a logic analyser provides a way to see what these signals look like, and hopefully provide a greater understanding of the protocols used in modern electronics.SetupConnecting the Digital Explorer BoardConnecting the Digital Explorer Board is as simple as plugging it into a 5V power source, preferably your laptop so you can modify the code. Once connected to your laptop, it’ll show up as a mass storage device CIRCUITPY and by opening the code.py file found within you can modify the code running on it. The code is all written in Python and when saved is automatically run - all on device!To see the output from your code, use a serial monitor tool (e.g. Putty for Windows, screen for Linux) to connect to the COM or dev/ttyACM port that enumerates when the device is plugged in. For more info, check out the CircuitPython docs.Connecting the Logic AnalyserBefore connecting the logic analyser, we need to install Pulseview, an open source logic analyser tool.Sparkfun has a great document on how to setup the software to work with your logic analyser.To connect the logic analyser to the Digital Explorer Board, we need to plug in the interceptor board, which acts as a passthrough between bPod and the Digital Explorer Board, whilst providing a pinout to plug the logic analyser into. When connecting the logic analyser, ensure the USB port is pointing in the same direction as the port on the Digital Explorer Board, as otherwise smoke may escape from your PC!Ensure you set the sample rate to at least 1MHz, otherwise the sample speed will be too slow to detect some of the signals!Connecting bPodbPod plugs into the interceptor board upside down, as shown in the below image. You’ll notice the interceptor board has one fewer pin than bPod, this is to prevent smoke if plugged in the wrong way.For reasons I can’t tell you (cough cough CTF) plugging bPod into the board will cause I2C issues with the MCP23017, so you’ll need to comment that code out (or put the RP2040 into bootloader by holding the BOOT button on the Pico and pressing the reset button) depending on what you want to do.Tour of the Digital Explorer BoardThe digital explorer board contains a number of common ICs found in modern electronics. They are summarised below: Part Number Type Comms Protocol Datasheet   74HC595 8-Bit Shift Registers With 3-State Output Registers SPI https://www.ti.com/lit/ds/symlink/sn74hc595.pdf   74HC165 8-Bit Parallel-Load Shift Registers SPI https://www.ti.com/lit/ds/symlink/sn74hc165.pdf   MCP23017 16-Bit I/O Expander with Serial Interface I2C https://ww1.microchip.com/downloads/aemDocuments/documents/APID/ProductDocuments/DataSheets/MCP23017-Data-Sheet-DS20001952.pdf   LSM6DS3 Inertial Module: 3D Accelerometer and 3D Gyroscope I2C https://www.st.com/resource/en/datasheet/lsm6ds3tr-c.pdf   WS2812B Addressable LED Proprietary https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf   The board also has a number of DIP switches and LEDs to interact with: MCP ADDR is used to set the I2C address of the MCP23017 from 0x20 to 0x27. MCP IO is connected to 4 input pins on the MCP23017, and the state of these DIP switches is mirrored to the LEDs below. SHIFT REG IO is connected to the 74HC165, and the corresponding LEDs are connected to the 74HC595. WS2812 LEDs are located at the top of the board, and display pretty colours. The data signal going into each LED is broken out below the bPod connector.The board also breaks out a UART from the RP2040 the bPod connector. For more info on how this is all connected check out the schematic.What is SPI / I2C / UART?Much like on the digital explorer board, a typical printed circuit board assembly will consist of a microcontroller as the brains of the operation, and a number of peripherals to perform specific tasks which the microcontroller cannot. To interface between the micro and peripheral, a number of standardised communication interfaces exist to allow part from varying manufactures to exist together.These days most microcontrollers operate at 3.3V, and as such a logic 1 is when the voltage at the pin is 3.3V, and a logic 0 when the voltage is zero.SPI - Serial Peripheral InterfaceSPI is one of the most common interfaces, and is typically configured in a controller / peripheral (master / slave) configuration with the following pins: SCLK Serial Clock (driven from controller) COPI Controller Out Peripheral In (data output from controller) CIPO Peripheral Out Controller In (data output from peripheral) nCS Chip Select (active low signal to begin transmission)SPI is a simple interface which allows high data throughput, making it a great option for both simple devices like shift registers, all the way to SD cards and TFT displays.Sparkfun has a great document going into all the details about SPI.I2C - Inter-Integrated CircuitI2C is also another common interface, and is unique in that you can connect 127 devices together using only two pins. SDA Serial Data SCL Serial ClockDue to having multiple devices on a shared bus each device has an address, and the controller needs to send the device address before sending data or a command. This greatly reduces the data throughput for a device on I2C, but for slow changing signals (e.g. LEDs, temperature) it’s a great solution as it does not require a high pin count from the microcontroller.Once again, Sparkfun goes into great detail about the inner workings of I2C.UART - Universal Asynchronous Receiver-TransmitterIf you’ve ever plugged in a cable and opened a terminal to an embedded device, you were most likely using UART to communicate with the device. It’s commonly used for communication between two microcontrollers, or between human and microcontroller. TX Transmit (leaving micro) RX Receive (entering micro)As UART is asynchronous, both devices need to be configured to the correct baudrate (bits per second) along with length, stop, and parity bits. There are two common speeds (9600 and 115200) and the so called “8N1” (8 bits, no parity, one stop) configuration which are used by most devices.You can probably guess what this link is if you’d like to learn more about UART.WS2812B - Individually Addressable LEDsWhilst WS2812Bs are not a communication protocol, they are a LED used in many hobby projects as you can have an infinite chain of RGB LEDs controlled by a single microcontroller pin.It uses a single pin which toggles between high and low, with the time high / time low indicating a 1 or a 0. These 1 and 0’s are formed into a packet containing the R/G/B value for each LED, and sent down the chain to make your PCBs look pretty.Page 4 of the datasheet goes into more detail about this protocol.What Does the Board Do?To demonstrate the above discussed protocols, after configuring the peripherals the the code on the RP2040 talks to each device in a big super loop, enabling you to see how changing the DIP switches / angle of the board impacts the messages being sent over the wires.Reading 74HC165 Shift Register ValuesDo NOT have bPod connected for this demoWith SPI, the below sequence of operation is used to read values. Assert chip select (normally low, but for the 74HC165 it’s active high) Clock rising edge causes peripheral to shift out data Controller reads data that was shifted out Clock goes low Do it all over again until all data has been read Chip select releasedThe below code shows how this is done on the RP2040# Shift in 8 bits from 165 shift registerdef shift_in(): # Var to store read value in readback = 0 # Set chip select high to begin read # Normally chip select is active low, but it's not this time # I know the name is wrong, but I'm keeping it identical to the schematic / PCB si_nlatch.value = True # For the 8 inputs on the shift register, read them into the temp var for i in range(0, 8): # Clock going high triggers shift out of next value si_clk.value = True # Bitwise or with 0 will set value if set on shift reg readback |= (si_data.value) &lt;&lt; (7-i) # Clock low so we can bring it high next time si_clk.value = False # Transaction over, return chip select to default state si_nlatch.value = False # Bitshifting to align values to MSB and invert as DIP switch is active low return (readback &lt;&lt; 3) ^ 0xFFThe below trace from Pulseview shows bits 4 and 5 being high, with the rest low.Writing 74HC595 Shift Register ValuesDo NOT have bPod connected for this demoWriting the above read values out to the 74HC595 is more or less the same, with the change that the controller sets the data pin with the value before setting the clock high.# Shift out 8 bit field to 595 shift registerdef shift_out(bitfield): # Chip enable low to begin transaction so_nlatch.value = False # For each bit in the bitfield for i in range(0, 8): # Set clock low so_clk.value = False # Check if bit is set and set data high / low accordingly if bitfield &amp; (1 &lt;&lt; i): so_data.value = True else: so_data.value = False # Clock going high shift the above set data in so_clk.value = True # Return data to zero value (not required, but easier for timing) so_data.value = False # Ensure clock is low when transaction finished so_clk.value = False # Chif enable high now transaction is done so_nlatch.value = TrueYou can see the below has six outputs high and two low, which maps to the bitshifted value we got back from the 165 input read.The reason for the bits not lining up exactly is that the pins were swapped to make PCB routing easier, and the alignment is handled in software.Reading and Writing MCP32017 GPIO Expander ValuesDo NOT have bPod connected for this demoI2C takes more than a dozen lines of code to control, so I’ve used the CircuitPython busio library for this example. It does however make the demo a bit more complicated than I’d like due to how it handles the IO.The logic trace shows the below. Setup Address Write to 0x20 (MCP Address) Tell MCP we want to read read register 0x12 0x12 is the GPIOA register, which stores the state for the IO pins Setup read to MCP Read two bytes (0x0C, 0x03) It appears the default library reads both ports at once, as the second byte (addr 0x13 is for GPIOB) Setup write to MCP Write two bytes at 0x12 (i.e. write the values out to the MCP) Interspersed between all of this are ACKs and NAKs which are used to confirm the peripheral has received the instruction and will act upon it (or not!).Reading LSM6DS3 Accelerometer ValuesDo NOT have bPod connected for this demoBy comparison to the MCP23017, the LSM6DS3 I2C read is a lot more straightforward. Talking to chip address 0x6A (LSM), read address 0x28 (OUT_X_L_XL). Taking to LSM, read 6 bytes from above address. Each X, Y, Z value is 16 bits (two bytes), so reading 6 bytes will read out all the data at once. Writing Data Stream Over UARTConnect bPod for this demo, however you’ll have to comment out all the MCP23017 code otherwise it won’t run (lines 24-57, 179-182)Connect your bPod, and navigate to the Tools -&gt; uartterm page. With the setting of 115200/8N1, select Terminal.You should now see Hello World! being printed on the screen.From the logic analyser, you should also be able to decode this message.Controlling MCP23017 from bPodConnect bPod for this demo, however you’ll have to comment out all the MCP23017 code otherwise it won’t run (lines 24-57, 179-182)bPod has the ability to control the MCP23017 IO expander just like we do on the digital explorer board. Go to tools, and run i2csniff to check the address of your MCP23017. I’ll be in the range of 0x20 - 0x27. Then go to the MCP23017 tab, set the address to the above. Toggle IOB0 - IOB3, and you should see the LEDs toggle on and off.Controlling WS2812B Addressable LEDsDo NOT have bPod connected for this demoWS2812B’s take a serial stream of packets into the first LED, and pass on packets 2…n to the next LED. This can be seen in the below stream, where three bytes make it to the first LED, two to the second LED, and one to the third (last) LED in the stream." }, { "title": "Soldering Equipment", "url": "/soldering-equipment/", "categories": "", "tags": "", "date": "2023-08-31 20:00:00 +1000", "snippet": "One of the common questions I get after running a workshop where soldering is involved is “I want to do this at home, what gear do you recommend?” This page is here to answer the question.Please no...", "content": "One of the common questions I get after running a workshop where soldering is involved is “I want to do this at home, what gear do you recommend?” This page is here to answer the question.Please note the suggestions here are targeted at someone who will solder every once in a while, if you do it regularly you may want to grab higher end equipment.Good value for money soldering iron: https://www.ebay.com.au/itm/125778321513Even better soldering iron (requires external power brick): https://customkbd.com/collections/tools/products/pinecil-soldering-ironGood solder and flux is expensive but well worth the money.Solder: https://au.element14.com/multicore-loctite/d622-250g-reel/solder-wire-60-40-0-71mm-250g/dp/419280Flux: https://au.element14.com/chip-quik/smd291nl/flux-syringe-5cc/dp/185022001?st=smd291Other tools and consumables don’t have to break the bank.Tweezers: https://www.aliexpress.com/item/32871375960.htmlSolder wick (2mm): https://www.aliexpress.com/item/4000261361770.htmlSide cutters: https://www.aliexpress.com/item/1005005122604670.htmlSolder sucker: https://www.aliexpress.com/item/1005002976983491.htmlA hot air station is a must for reworking surface mount components.Hot air station: https://www.ebay.com.au/itm/134378011610Holding PCBs steady whilst soldering can be a challenge, the below works very well but is quite expensive. The stock jaws can melt, so I’d suggest getting the high temp upgrade.Vice: https://au.mouser.com/ProductDetail/Adafruit/3197?qs=JnzaLlyswt54yfC%2F88S7fg%3D%3DHigh temp jaws: https://au.mouser.com/ProductDetail/Adafruit/3198?qs=sGAEpiMZZMtyU1cDF2RqUImK8UYnVH7l27MZjPptck8%3D" }, { "title": "Handwiring Wombat, a 200% keyboard", "url": "/wombat/", "categories": "", "tags": "", "date": "2022-09-26 20:00:00 +1000", "snippet": "Two months ago I was sitting at home, browsing Discord, and see this screenshot posted by Laser Ninja.For those who haven’t seen it before, Wombat is a 200ish% percent keyboard designed by Jono, an...", "content": "Two months ago I was sitting at home, browsing Discord, and see this screenshot posted by Laser Ninja.For those who haven’t seen it before, Wombat is a 200ish% percent keyboard designed by Jono, and looks something like the below.After a few messages trying to figure out the feasibility of handwiring up such a monstrous keyboard, and offers of help from Rory and Ant, I replied to Jono saying I’d be keen to give it a go.A month or so later, Jono was in Melbourne and called past the CustomKBD meetup to drop off the chassis for the build.Over the next few weeks Rory designed and I 3d printed stabiliser and encoder mounts, as they are normally attached to the PCB, but we don’t have one!Fortunately the bottom of the case is parallel to the plate, so it wasn’t too challenging to design the parts. Or maybe it was challenging and Rory made it look easy. I’ll never know.I also designed a diode bender to ensure we got consistent placement of the diodes and that they’d be able to span from key to key.With the mechanical side of things under control, I shifted gears to how we were going to connect all 218 switches and 20 encoders to the host PC. I concluded that two Sea-Picros per side would be the way to go, with one Sea-Picro taking care of the 20 wires for the A/B channels of the encoders, and the other for the 23 column / rows for each half of the board.With this said, as Sea-Picro only has 23 IO (plus a dedicated 5V output for driving LEDs), I had to rip off the level shifter for this extra pin and repurpose it to being the wire sending the signals between the splits. Given there are two split keyboards in the case, and only one USB port, I also designed up a 4 port USB hub (all 4 ports are used to flash the micros, and then the slave side of the splits are disconnected before connecting to the host PC), and a daughterboard to fit into the case.With the above boards being held in by some M2 screws, I cut a JST SH cable down and soldered to each of the Sea-Picros, then hot glued and stuck them all into the case. Prior to gluing the Sea-Picros in, I conformally coated the PCBs to protect all the downwards facing components from shorts and glue, stuck a layer of kapton tape on top, then threw hot glue on the kapton tape and fitted to the plate. Kapton tape was also applied to the plate, as the hot glue did not stick to the anodised aluminum.With the electronics sorted, I installed the rotary encoders, stabiliser mounts, and marked up which side of the board was which, and we were ready to begin the handwiring process!Come stream day, I had high hopes we’d be able to get the matrix up and running, but I wasn’t too sure about the encoders. We started the day with Rory lubing stabs whilst I bent and soldered diodes, to Rory bending diodes whilst I soldered them, to finally Rory playing with slot cars whilst Ant gave me a hand soldering diodes. After multiple declarations of “all the diodes are done” followed by finding some which were not, we wrapped up the day seven hours later with all the diodes having been soldered.Over the next week I proceeded to spend an additional eleven hours streaming the handwiring destroying my back, until we finally got the below monstrosity completed.With the electronics up and running, I taped the bottom of the case to prevent shorts and added extra tape under the stabs to try and damp any noise coming through the direct contact of the stabs to the bottom of the case.After screwing the case together, I added two sets of keycaps, 64 relegendables, and a bunch of knobs on the board and recorded the below sound test. Putting aside the loud space bar which needs more work I’m extremely happy with how it turned out.With the sound test done, it was time to call the build complete and reflect on the 50ish hours of work that brought us to this point. Whilst there are a few things that could have been done better, it all worked out very well and I’ve been enjoying typing up this post on Wombat.A huge thanks has to go out to Jono of Impulse Boards for offering a Wombat up for this crazy project, as for obvious reasons there is no way this would have gone ahead without him.Rory (Instagram, Discord) was also instrumental to this project going smoothly as without him I’d have used a lot more hot glue to hold the stabs in, and they wouldn’t be lubed to perfection.Ant from CustomKBD not only hosted us for the Saturday stream, but supplied the stabs that Rory forgot to bring along with the keycaps and leant a hand soldering. 0ldmate from Mountain Keyboards is a good friend and was the source for the Gateron Black switches used in the build.Finally, thanks to Laser Ninja for linking Jono’s post which kicked this all off, Timatoee for the patch you can see throughout the streams, along with everyone who tuned in and provided words of support throughout.With all the above said, please enjoy the below photos and if you have any questions don’t hesitate to get in touch." }, { "title": "Robcats Keyboard Workshop Assembly Instructions", "url": "/robocats-keyboard/", "categories": "", "tags": "", "date": "2022-09-19 20:00:00 +1000", "snippet": "IntroductionThe goal of today’s workshop is to provide an introduction to soldering and programming through building a small mechanical keyboard. By the end of the workshop you should have a keyboa...", "content": "IntroductionThe goal of today’s workshop is to provide an introduction to soldering and programming through building a small mechanical keyboard. By the end of the workshop you should have a keyboard consisting off three keys and a rotary encoder that you can program to perform any task you can imagine. This could span from a simple volume knob, to dedicated copy / paste keys, or even typing the entire bee movie script with one keypress.SolderingRequired PartsWe will be using the below components during today’s workshop, and will be handed out as you get to each step. 1 x Sea-Picro (1) 1 x PCB (2) 2 x 12 pin headers (3) 4 x Diodes (through hole (4) or surface mount (5)) 3 x Keyswitches (6) and keycaps (7) 1 x Rotary encoder (8) and knob (9)The LEDs (10) will be pre soldered, and the reset switch (11) is not required.You will also require the following tools. Soldering iron Solder Tweezers Flush cut side cuttersSoldering TipsThe most important thing to remember with soldering is that the solder flows to wherever is hot. As such it’s important to heat up the components you are trying to solder before feeding solder into the joint. A rough rule of thumb is to hold your iron against the components for a second before feeding solder into the component being soldered, not the iron. This will ensure the solder sticks to the parts you are trying to attach to the circuit board, and not just pool up on the iron.Here is a short video showing how to solder, with the first 15 seconds demoing the above instructions.DiodesOn a normal keyboard, diodes are used to prevent an effect known as “ghosting”, where the microcontroller thinks more keys are pressed than actually are when specific key combinations are pressed. You will see diodes in two different package types, a glass tube with leads (through hole) and a black rectangle with small pads (surface mount). If you’ve never soldered before I’d suggest using the through hole diodes, however if you are after a challenge the surface mount option is also available.Through Hole DiodesWe first need to bend the leads on the diode to be the same width as the holes in the PCB.Then insert it, ensuring the black bar on the diode is aligned with the white bar on the PCB.To hold it in place whilst soldering, flip the board over and bend the leads outwards.Solder one of the leads.Flip the board back over and check the diode is still flush with the PCB, if not heat up the joint and move into position.With the diode in place, solder the remaining lead.Finally, trim the leads using the flush cut side cutters. Please point the side cutters towards the desk when cutting so the leads don’t go flying around the room.Surface Mount DiodesLike through hole diodes, surface mount diodes are directional and won’t work if installed backwards. They have a horizontal line on one end of the package which lines up with the line on the PCB. This can sometimes be hard to see, but shining light from the side of the package will help reveal the marking.As we have done previously, add solder to one pad.Then ensuring the component is in the correct orientation, tack one pin in place.Then solder the remaining pin in place.Finish soldering all four diodes, and you’ll have a board that looks like the below. (You can pick and choose through hole vs surface mount depending on how much of a challenge you are seeking.)MicrocontrollerThe microcontroller is the brains of any keyboard, with it scanning for key presses, figuring out what key was pressed, then sending the relavent keypress up to the computer all in a fraction of a second. A RP2040 based board, Sea-Picro, was chosen for this project as it can be programmed in python without installing a toolchain and has good supply even during the chip shortage.We first need to solder the pin headers to the microcontroller, and can use the PCB to keep the pins aligned as shown below. The pin header is one pin shorter than the IO on Sea-Picro, please leave the empty pin at the USB connector end as shown in red. Solder the pins at the end of each header.With the headers tacked in place, confirm the pins are square to the microcontroller. If they are not, heat up one of the solder joints, and gently push the connector into alignment. Make sure you don’t touch the pin you are heating up otherwise you’ll burn yourself! Once the pins are square solder all of the pins. (sorry for the blurry photo)With all the pins soldered on Sea-Picro, ensure it’s placed on the same side as the diodes with the USB connector facing towards the edge of PCB as per the above photo.Please ask a mentor to confirm the orientation is correct, as if it’s incorrect your board will not work!With Sea-Picro oriented correctly, flip the board upside down and tack two opposing corners in place on the PCB.If Sea-Picro isn’t sitting flush to the PCB, heat up a pin and adjust as necessary.With the microcontroller sitting flush to the PCB, solder the remaining pins. (forgot to photograph this step)With all the pins soldered, snip off the legs so they don’t stick out. Please take care so the pins don’t go flying around the room.SwitchesSwitches are arguably the most important part of a keyboard, as without them you wouldn’t be able to type anything! They come in a variety of options with different force profiles, but regardless of what switch you pick the install process is the same.First, grab a switch and place it in the position you want. Remember we are fitting a rotary encoder as well so consider where you want that to live as it’s much taller than a switch. In this case, I’m installing switches in 1,2,3, and an encoder in 0.With the switch pressed into place, flip the board over and solder the pins in. Repeat for the other two switches.EncodersIn addition to the push button/switch in the encoder that shorts two pins when pressed, the encoder has two additional outputs that go high / low as the knob is turned, sending the direction of rotation to the microcontroller. As such you can turn the encoder for as many revolutions as you’d like, so they are a great way to control continuous values such as volume or opacity.The first step is to snip both mounting legs off the encoder with the side cutters.With the legs removed, insert the encoder into the PCB and tack opposing pins in place. Don’t solder all the pins yet.With the pins tacked into place, ensure the encoder is sitting flush / square on the board, and adjust as necessary. When square, solder the remaining pins.With all of the encoder pins soldered, install the keycaps and knob, and celebrate finishing the soldering of your new keyboard!Firmware ConfigurationOut of the box, Sea-Picro (and the RP2040 microcontroller within) has no idea what it’s purpose in life is, so we need to configure it to not only be a keyboard, but one which works with our custom made PCB, and your custom keycodes. To do this, we will be using KMK, a CircuitPython based keyboard firmware framework, due to it’s ease of programming - all you need to do it edit a text file and when you save the code it will run.To make programming easier, please install Mu, which is the recommended editor for CircuitPython and has an inbuilt serial terminal which allows us to talk to your keyboard for debugging purposes.Sea-Picro comes flashed with CircuitPython out of the box, but we need to load KMK and the code.py file with our keyboard configuration. The steps are below: Download a copy of KMK. Unzip it and copy the KMK folder and the boot.py file at the root of the USB drive corresponding to your board (often appearing as CIRCUITPY). Unplug and replug your device to force the boot.py changes to be implemented. Using Mu, open the existing code.py file on the CIRCUITPY drive and replace it with the below code.# Sea-Picro pinoutimport board# KMK driversfrom kmk.kmk_keyboard import KMKKeyboardfrom kmk.scanners.keypad import KeysScannerfrom kmk.modules.encoder import EncoderHandlerfrom kmk.extensions.RGB import RGB, AnimationModes# Different keycodes that can be sentfrom kmk.keys import KCfrom kmk.extensions.media_keys import MediaKeysfrom kmk.handlers.sequences import send_stringfrom kmk.handlers.sequences import unicode_string_sequencefrom kmk.handlers.sequences import simple_key_sequence# Init keyboardkeyboard = KMKKeyboard()# Mapping IO pin to position in matrix# Comment lines in / out depending if you are using diodes or not# keyboard.matrix = KeysScanner([board.D21, board.D23, board.D20, board.D22,]) # Without diodeskeyboard.matrix = KeysScanner([board.D29, board.D28, board.D27, board.D26,]) # With diodes# Add encoders, RGB, and media key support to keyboardencoder_handler = EncoderHandler()rgb_ext = RGB(pixel_pin=board.D7, num_pixels=3, val_limit=255, val_default=64, animation_mode=AnimationModes.RAINBOW,)media_keys = MediaKeys()keyboard.modules = [encoder_handler, media_keys, rgb_ext]# Configure encoder pins# As the encoder can be placed in multiple spots we don't define which IO the# push button is mapped to, and instead leave that for the switch matrix definitionencoder_handler.pins = ((board.D9, board.D8, None, False),)# Examples of different keys that can be sent# All valid keys: https://github.com/KMKfw/kmk_firmware/blob/master/docs/keycodes.md#keys-overview# Strings: https://github.com/KMKfw/kmk_firmware/blob/master/docs/sequences.md#sending-stringsEG_STRING = send_string(\"According to all known laws of aviation, there is no way a bee should be able to fly. Its wings are too small to get its fat little body off the ground.\")# Unicode (requires config on your PC first) https://github.com/KMKfw/kmk_firmware/blob/master/docs/sequences.md#unicodeEG_UNICODE = unicode_string_sequence('(っ◔◡◔)っ ❤')# Chains of key pressesEG_COPY = KC.LCTL(KC.C)EG_PASTE = KC.LCTL(KC.V)# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ KC.MPLY, EG_STRING, EG_COPY, EG_PASTE ]]# Below configures what happens when the encoder is turnedencoder_handler.map = (((KC.VOLD, KC.VOLU, None),),)# With everything configured, time to become a keyboard!if __name__ == '__main__': keyboard.go()Press the keys / turn the encoder on your keyboard and see if they all work. By default they will work as below. SW0 / Encoder: Media Play / Pause SW3: Prints the first line of the Bee movie script. SW2: Copy SW3: Paste Encoder Clockwise: Volume Up Encoder Anticlockwise: Volume DownIf you have issues, check the diodes are installed in the correct orientation and all pins are soldered. Just incase you have issues with the diodes, there is a “no diode” IO configuration on line 22 that can be commented in to check if the diodes are the issue or if it exists somewhere else.Assuming everything is working, it’s time to jump to mechanical assembly and attach the base before returning here to configure the keyboard to send whatever keycodes you want. Below are a few links to KMK documentation to help guide you. There’s a reference of the available keycodes. International extension adds keys for non US layouts and Media Keys adds keys for … media.And to go even further: Sequences are used for sending multiple keystrokes in a single action. Layers can transform the whole way your keyboard is behaving with a single touch. ModTap allow you to customize the way a key behaves whether it is tapped or hold, and TapDance depending on the number of times it is pressed. RGB allows you to control addressable LEDs.If you make a change and notice your board is no longer working, there is a good chance there is a bug somewhere that is preventing the code from running. If this is the case, the onboard RGB LED will blink a error code that corresponds to the below. 1 GREEN blink: Code finished without error. 2 RED blinks: Code ended due to an exception. Check the serial console for details. 3 YELLOW blinks: CircuitPython is in safe mode. No user code was run. Check the serial console for safe mode reason.Mechanical AssemblyWith the electronics done, it’s time to assemble the case. Check you have the below before continuing. 1 x Acrylic base 4 x M2 standoffs 8 x M2 bolts 4 x Bumpons 1.5mm hex/allen keyStart by removing the protective paper off the acrylic base.Grab a screw and standoff, and screw into one of the holes in the acrylic.Repeat for all four corners.Using a 1.5mm allen key, screw the PCB to the standoffs with the remaining screws.Finally, add the bumpons to four corners of the acrylic.Now it’s time to sit back and enjoy all of your hard work, as you’ve successfully assembled your new keyboard and can begin programming it.Programming ChallengesWith all the above done, you should have a fully functioning keyboard whose function is only limited by your imagination (and the rules of physics). If there is time left in the workshop, please play around with the code and configure it’s functionality to things you find interesting.If you’d like some ideas, give the below a go: Configure keys to change the colour of the RGB LEDs. Hint, Answer. Set the encoder to change the LED brightness when you turn it. Hint, Answer. Configure one key to press CTRL + L, another to type the RoboCats website URL, and a third to press enter, allowing you to visit the RoboCats website quickly (when pressed within a web browser). Hint, Answer. Combine the above into a single key press. Hint, Answer. Write a function that types 3, waits a second, 2, waits a second, 1, waits a second, then types Liftoff!. Hint, Answer. Use a tool such as TextKool to generate fancy RoboCats text and type it with one key press. Hint, Answer. Print the below ASCII art of Shrek to the Mu serial terminal with a single key press. Hint, Answer. ⢀⡴⠑⡄⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡇⠀⠿⡀⠀⠀⠀⣀⡴⢿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⣠⠾⠁⣀⣄⡈⠙⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠁⠀⠀⠈⠙⠛⠂⠈⣿⣿⣿⣿⣿⠿⡿⢿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⣁⣀⠀⠴⠂⠙⣗⡀⠀⢻⣿⣿⠭⢤⣴⣦⣤⣹⠀⠀⠀⢀⢴⣶⣆⠀⠀⢀⣾⣿⣿⣿⣷⣮⣽⣾⣿⣥⣴⣿⣿⡿⢂⠔⢚⡿⢿⣿⣦⣴⣾⠁⠸⣼⡿⠀⢀⡞⠁⠙⠻⠿⠟⠉⠀⠛⢹⣿⣿⣿⣿⣿⣌⢤⣼⣿⣾⣿⡟⠉⠀⠀⠀⠀⠀⠀⣾⣷⣶⠇⠀⠀⣤⣄⣀⡀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠉⠈⠉⠀⠀⢦⡈⢻⣿⣿⣿⣶⣶⣶⣶⣤⣽⡹⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠲⣽⡻⢿⣿⣿⣿⣿⣿⣿⣷⣜⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣷⣶⣮⣭⣽⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⠿⠿⠿⠛⠉ HintsHint: Change Colour RGB Check out the RGB Key Codes. You’ll need to put the board into plain mode, then use Hue to adjust the colour. This can be done by altering the keymap.Hint: Encoder Brightness Change This is very similar to the colour change problem above, except you want to change the brightness (Value) and map those keycodes to the encoder.Hint: Visit RoboCats Website In the example code we have this keycode EG_COPY = KC.LCTL(KC.C), which presses CTRL + C to copy. Try modifying this to press CTRL + L instead, and update the name from EG_COPY to something more relevant. Then try modifying the send_string example to print the RoboCats URL https://www.melbournerobocats.com/. You might notice that after the URL is typed we need to press enter, so add that to your keymap as well.Hint: RoboCats Website Single Key We will use Key Sequences to press keys in sequence. Look at the example simple_key_presses at the above link and modify it to use the keycodes we made earlier. You’ll need to define this sequence below the keycodes you want to use.Hint: 3 2 1 Liftoff! We can use the simple_key_presses per the previous challenge, but will need to add KC.MACRO_SLEEP_MS(1000) in between steps to delay by 1 second. To make the text appear on a new line each time, you can either use KC.ENTER as a keycode, or add a newline \\n to the end of a string.Hint: Fancy RoboCats Text As we’ve seen in the previous challenge, we can use send_string in a sequence to print multiple lines of text. We need to ensure we only use a font that uses standard keycodes, for example the one I’ve generated below: _____ ____ ____ ____ _____ _______ _____ | __ \\ / __ \\| _ \\ / __ \\ / ____| /\\|__ __/ ____|| |__) | | | | |_) | | | | | / \\ | | | (___ | _ /| | | | _ &lt;| | | | | / /\\ \\ | | \\___ \\ | | \\ \\| |__| | |_) | |__| | |____ / ____ \\| | ____) ||_| \\_\\\\____/|____/ \\____/ \\_____/_/ \\_\\_| |_____/ If we copy and paste each line of the above text into a separate send_string command, we should be able to print the text one line at a time. We’ll either need to add a newline \\n or KC.ENTER at the end of each string to ensure it prints on multiple lines.Hint: Shrek Print This problem is a challenging one, as the picture of Shrek uses characters that you can’t type on a keyboard, so we can’t send keycodes as we’ve done above. We can however send it over the serial terminal to Mu, where we can then copy and paste it to a text editor on your PC. The KMK developers have this as an example, so scroll to the bottom of this page and give it a go. You’ll need to open the Mu serial terminal to see the work of art be printed out.AnswersAnswer: Change Colour RGB We will use the RGB Key Codes to adjust the LEDs. Once we find the keycodes we want to use, we can update the keymap with the new codes. KC.RGB_MODE_PLAIN will be used to change the animation mode from rainbow to plain, as otherwise the Hue codes are not acted upon. KMK uses HSV (Hue, Saturation, Value) for colour control, and Hue is how we adjust colour. Add the KC.HUI (Hue Increase) and KC.HUD (Hue Decrease) keycodes into the keymap. With the keymap updated (see below), tap the PLAIN key, then you can use the HUI and HUD keys to adjust the colour.keyboard.keymap = [ [ KC.MPLY, KC.RGB_MODE_PLAIN, KC.RGB_HUI, KC.RGB_HUD ]]Answer: Encoder Brightness Change As above, we will use the RGB Key Codes, but update the encoder keymap instead of the keyboard switch keymap. Value is the HSV equivalent of Brightness, so KC.RGB_VAI and KC.RGB_VAD are the keycodes we will use. Updating the encoder keymap with these for clockwise / anticlockwise as shown below should get us the desired result. If the value increases when you turn anticlockwise (and you want it to decrease), swap the location of the two keycodes.encoder_handler.map = (((KC.RGB_VAD, KC.RGB_VAI, None),),)Answer: Visit RoboCats Website We can modify the EG_COPY = KC.LCTL(KC.C) line to URL = KC.LCTL(KC.L), which will move your cursor to the URL bar in your browser. Similarly, editing the string example EG_STRING = send_string(\"According ...\") to ROBO_URL = send_string(\"https://www.melbournerobocats.com/\") will type out the URL. We then need to add KC.ENTER to our keymap so we can press enter after typing out the URL.URL = KC.LCTL(KC.L)ROBO_URL = send_string(\"https://www.melbournerobocats.com/\")# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ KC.MPLY, URL, ROBO_URL, KC.ENTER ]]Answer: RoboCats Website Single Key Using Key Sequences we can press the keys we defined in the last challenge all in one go. If we enter the keycodes we made in the previous challenge into the example linked above, it will look something like the below. Adding ROBO_URL_SINGLE to our keymap will then allow us to trigger this sequence.URL = KC.LCTL(KC.L)ROBO_URL = send_string(\"https://www.melbournerobocats.com/\")ROBO_URL_SINGLE = simple_key_sequence( ( URL, ROBO_URL, KC.ENTER, ))# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ ROBO_URL_SINGLE, URL, ROBO_URL, KC.ENTER ]]Answer: 3 2 1 Liftoff! We will use Key Sequences as we did in the previous challenge to solve this. You can either type 1 2 3 using the keycodes, or send them as a string, but will need to type Liftoff! as a string. We will press KC.ENTER after typing each key, and append a newline to the Liftoff! string. Between each step KC.MACRO_SLEEP_MS(1000) will be called to create a delay. The function accepts a time in milliseconds (thousandths of a second) so we will pass 1000 to get a one second delay.LIFTOFF = simple_key_sequence( ( KC.N3, KC.ENTER, KC.MACRO_SLEEP_MS(1000), KC.N2, KC.ENTER, KC.MACRO_SLEEP_MS(1000), send_string(\"1\\n\"), KC.MACRO_SLEEP_MS(1000), send_string(\"LIFTOFF!\\n\"), ))# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ LIFTOFF, URL, ROBO_URL, KC.ENTER ]]Answer: Fancy RoboCats Text As explained in the hint, we will use multiple send_string functions to print each line of the text. We need to append a \\n or KC.ENTER to the end of each line to ensure they print on a new line each time. One possible solution is shown below.FANCY_ROBO = simple_key_sequence( ( send_string(\" _____ ____ ____ ____ _____ _______ _____ \\n\"), send_string(\"| __ \\ / __ \\| _ \\ / __ \\ / ____| /\\|__ __/ ____|\\n\"), send_string(\"| |__) | | | | |_) | | | | | / \\ | | | (___ \\n\"), send_string(\"| _ /| | | | _ &lt;| | | | | / /\\ \\ | | \\___ \\ \\n\"), send_string(\"| | \\ \\| |__| | |_) | |__| | |____ / ____ \\| | ____) |\\n\"), send_string(\"|_| \\_\\\\____/|____/ \\____/ \\_____/_/ \\_\\_| |_____/ \\n\"), ))# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ FANCY_ROBO, URL, ROBO_URL, KC.ENTER ]]Answer: Shrek Print First, we copy and paste the example code from the KMK example to our code. Place above the keymap. Looking at the code, we can see when we press LALT it will call the shrek function that prints the image. As such, if we add the KC.LALT keycode to our keymap, it should print Shrek whenever Left Alt is pressed. We then need to open Mu and go to the serial terminal to see the picture be printed. Once it’s been printed, you can copy and paste it in whatever text editor / messaging platform you like.def shrek(*args, **kwargs): print('⢀⡴⠑⡄⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀') print('⠸⡇⠀⠿⡀⠀⠀⠀⣀⡴⢿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠑⢄⣠⠾⠁⣀⣄⡈⠙⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⢀⡀⠁⠀⠀⠈⠙⠛⠂⠈⣿⣿⣿⣿⣿⠿⡿⢿⣆⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⢀⡾⣁⣀⠀⠴⠂⠙⣗⡀⠀⢻⣿⣿⠭⢤⣴⣦⣤⣹⠀⠀⠀⢀⢴⣶⣆') print('⠀⠀⢀⣾⣿⣿⣿⣷⣮⣽⣾⣿⣥⣴⣿⣿⡿⢂⠔⢚⡿⢿⣿⣦⣴⣾⠁⠸⣼⡿') print('⠀⢀⡞⠁⠙⠻⠿⠟⠉⠀⠛⢹⣿⣿⣿⣿⣿⣌⢤⣼⣿⣾⣿⡟⠉⠀⠀⠀⠀⠀') print('⠀⣾⣷⣶⠇⠀⠀⣤⣄⣀⡀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀') print('⠀⠉⠈⠉⠀⠀⢦⡈⢻⣿⣿⣿⣶⣶⣶⣶⣤⣽⡹⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠀⠀⠀⠉⠲⣽⡻⢿⣿⣿⣿⣿⣿⣿⣷⣜⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣷⣶⣮⣭⣽⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠀⠀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀') print('⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⠿⠿⠿⠛⠉') return False # Returning True will follow thru the normal handlers sending the ALT key to the OSKC.LALT.before_press_handler(shrek)# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ KC.LALT, KC.RGB_MODE_PLAIN, KC.RGB_HUI, KC.RGB_HUD ]]" }, { "title": "Intro Keyboard Assembly Instructions", "url": "/intro-keyboard/", "categories": "", "tags": "", "date": "2022-08-27 20:00:00 +1000", "snippet": "IntroductionBuilding a DIY keyboard consists of three main sections: soldering, mechanical assembly, and programming. The goal of this workshop is to provide an introduction to the above so you fee...", "content": "IntroductionBuilding a DIY keyboard consists of three main sections: soldering, mechanical assembly, and programming. The goal of this workshop is to provide an introduction to the above so you feel confident tackling a larger project of your own.By the end of the workshop you should be walking away with a keyboard consisting off three keys and a rotary encoder, that you can program to perform any task you can imagine. This could span from a simple volume knob, to dedicated copy / paste keys, or even typing the entire bee movie script with one keypress.SolderingRequired PartsBefore starting, ensure you have all the below components on hand. 1 x Sea-Picro 1 x PCB 2 x 12 pin headers 4 x Diodes (through hole or surface mount) 3 x WS2812B LEDs 1 x Reset Button 3 x Keyswitches and keycaps 1 x Rotary encoder and knobYou will also require the following tools. Soldering iron Solder Tweezers Flush cut side cutters 1.5mm hex/allen keySoldering TipsThe most important thing to remember with soldering is that the solder flows to wherever is hot. As such it’s important to heat up the components you are trying to solder before feeding solder into the joint. A rough rule of thumb is to hold your iron against the components for a second before feeding solder into the component being soldered, not the iron. This will ensure the solder sticks to the parts you are trying to attach to the circuit board, and not just pool up on the iron.Here is a short video showing how to solder, with the first 15 seconds demoing the above instructions.DiodesOn a normal keyboard, diodes are used to prevent an effect known as “ghosting”, where the microcontroller thinks more keys are pressed than actually are when specific key combinations are pressed. You will see diodes in two different package types, a glass tube with leads (through hole) and a black rectangle with small pads (surface mount). This kit allows you to pick and choose what package you want depending on how challenging you want it to be.Through Hole DiodesWe first need to bend the leads on the diode to be the same width as the holes in the PCB.Then insert it, ensuring the black bar on the diode is aligned with the white bar on the PCB.To hold it in place whilst soldering, flip the board over and bend the leads outwards.Solder one of the leads.Flip the board back over and check the diode is still flush with the PCB, if not heat up the joint and move into position.With the diode in place, solder the remaining lead.Finally, trim the leads using the flush cut side cutters.Surface Mount DiodesLike through hole diodes, surface mount diodes are directional and won’t work if installed backwards. They have a horizonal line on one end of the package which lines up with the line on the PCB. This can sometimes be hard to see, but shining light from the side of the package will help reveal the marking.As we have done previously, add solder to one pad.Then ensuring the component is in the correct orientation, tack one pin in place.Then solder the reminaing pin in place.Finish soldering all four diodes, and you’ll have a board that looks like the below. (You can pick and choose through hole vs surface mount depending on how much of a challenge you are seeking.)MicrocontrollerThe microcontroller is the brains of any keyboard, with it scanning for key presses, figuring out what key was pressed, then sending the relavent keypress up to the computer all in a fraction of a second. A RP2040 based board, Sea-Picro, was chosen for this project as it can be programmed in python without installing a toolchain and has good supply even during the chip shortage.We first need to solder the pin headers to the microcontroller, and can use the PCB to keep the pins aligned as shown below.The pin header is one pin shorter than the IO on Sea-Picro, please leave the empty pin at the USB connector end as shown in red.With the pin header in the correct position, tack one pin at each end of the header in place.With the headers tacked in place, confirm the pins are square to the microcontroller. If they are not, heat up one of the solder joints, and gently push the connector into alignment. Make sure you don’t touch the pin you are heating up otherwise you’ll burn yourself! Once the pins are square solder all of the pins. (sorry for the blurry photo)With all the pins soldered on Sea-Picro, ensure it’s placed on the same side as the diodes with the USB connector facing towards the edge of PCB as per the above photo.ENSURE THIS IS CORRECT OTHERWISE YOUR BOARD WILL NOT WORK.With Sea-Picro oriented correctly, flip the board upside down and tack two opposing corners in place on the PCB.If Sea-Picro isn’t sitting flush to the PCB, heat up a pin and adjust as necessary.With the microcontroller sitting flush to the PCB, solder the remaining pins. (forgot to photograph this step)With all the pins soldered, snip off the legs so they don’t stick out. I’d recommend cutting the leads towards the desk so they don’t go flying around the room.Reset SwitchNext we will solder the reset switch, which is commonly used to put the board into bootloader mode so you can flash different firmware / keymaps to the microcontroller. The board we are using (Sea-Picro) already has a reset button on it so this step is not required, but is good practice none the less.Place the PCB into the 3d printed soldering jig upside down. This was a last minute addition to the workshop so please excuse the bare PCB in the photo.First, put a small amount of solder onto one of the pads.Then using tweezers, place the reset switch in position and melt the solder you previously placed down to tack the reset switch in place.Add solder to the remaining pins to secure the reset switch in place.LEDsAdding LEDs to your board is a simple way of adding some colour to your desk, but it can also be used to identify the state of your keyboard, e.g. if it’s setup for macros or volume control. The LEDs used are known as “addressable LEDs” in that you send a serial sting of data to the LEDs to set their colour. Due to the packaging of addressable LEDs they can be a bit challenging to solder, so don’t hesitate to ask for help.Similarly to the reset switch, tin one pad of the LED footprint.Line up the white triangular marking in the corner of the LED with the “L” shaped corner of the marking on the PCB. This is crucial otherwise your board won’t work.As with the reset switch, heat up the previously placed solder and tack the LED in place.Then solder the remaining pins. You may find the pad with the “L” shaped marking more challenging to solder, and this is due to it being the ground plane which has a large thermal mass. If you get a blob of solder stuck to the LED like below, ensure you hold the iron to the PCB for a few seconds to heat it up before adding solder.Here is a video showing the entire process.Once you’ve soldered the first LED, continue doing the other two on the board until they are complete.SwitchesSwitches are arguably the most important part of a keyboard, as without them you wouldn’t be able to type anything! They come in a variety of options with different force profiles, but regardless of what switch you pick the install process is the same.First, grab a switch and place it in the position you want. Remember we are fitting a rotary encoder as well so consider where you want that to live as it’s much taller than a switch. In this case, I’m installing switches in 1,2,3, and an encoder in 0.With the switch pressed into place, flip the board over and solder the pins in. Repeat for the other two switches.EncodersIn addition to the push button/switch in the encoder that shorts two pins when pressed, the encoder has two additional outputs that go high / low as the knob is turned, sending the direction of rotation to the microcontroller. As such you can turn the encoder for as many revolutions as you’d like, so they are a great way to control continuous values such as volume or opacity.The first step is to snip both mounting legs off the encoder with the side cutters.With the legs removed, insert the encoder into the PCB and tack opposing pins in place. Don’t solder all the pins yet.With the pins tacked into place, ensure the encoder is sitting flush / square on the board, and adjust as necessary. When square, solder the remaining pins.With all of the encoder pins soldered, install the keycaps and knob, and celebrate finishing the soldering of your new keyboard!Firmware ConfigurationOut of the box, Sea-Picro (and the RP2040 microcontroller within) has no idea what it’s purpose in life is, so we need to configure it to not only be a keyboard, but one which works with our custom made PCB, and your custom keycodes. To do this, we will be using KMK, a CircuitPython based keyboard firmware framework, due to it’s ease of programming - all you need to do it edit a text file and when you save the code it will run.Sea-Picro comes flashed with CircuitPython out of the box, but we need to load KMK and the code.py file with our keyboard configuration. The steps are below: Download a copy of KMK. Unzip it and copy the KMK folder and the boot.py file at the root of the USB drive corresponding to your board (often appearing as CIRCUITPY). Unplug and replug your device to force the boot.py changes to be implemented. Open the existing code.py file on the CIRCUITPY drive with a text editor and replace it with the below code.# Sea-Picro pinoutimport board# KMK driversfrom kmk.kmk_keyboard import KMKKeyboardfrom kmk.scanners.keypad import KeysScannerfrom kmk.modules.encoder import EncoderHandlerfrom kmk.extensions.RGB import RGB, AnimationModes# Different keycodes that can be sentfrom kmk.keys import KCfrom kmk.extensions.media_keys import MediaKeysfrom kmk.handlers.sequences import send_stringfrom kmk.handlers.sequences import unicode_string_sequence# Init keyboardkeyboard = KMKKeyboard()# Mapping IO pin to position in matrix# Comment lines in / out depending if you are using diodes or not# keyboard.matrix = KeysScanner([board.D21, board.D23, board.D20, board.D22,]) # Without diodeskeyboard.matrix = KeysScanner([board.D29, board.D28, board.D27, board.D26,]) # With diodes# Add encoders, RGB, and media key support to keyboardencoder_handler = EncoderHandler()rgb_ext = RGB(pixel_pin=board.D7, num_pixels=3, val_limit=255, val_default=64, animation_mode=AnimationModes.RAINBOW,)media_keys = MediaKeys()keyboard.modules = [encoder_handler, media_keys, rgb_ext]# Configure encoder pins# As the encoder can be placed in multiple spots we don't define which IO the# push button is mapped to, and instead leave that for the switch matrix definitionencoder_handler.pins = ((board.D9, board.D8, None, False),)# Examples of different keys that can be sent# All valid keys: https://github.com/KMKfw/kmk_firmware/blob/master/docs/keycodes.md#keys-overview# Strings: https://github.com/KMKfw/kmk_firmware/blob/master/docs/sequences.md#sending-stringsEG_STRING = send_string(\"I'd just like to interject for a moment. What you're referring to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux.\")# Unicode (requires config on your PC first) https://github.com/KMKfw/kmk_firmware/blob/master/docs/sequences.md#unicodeEG_FLIP = unicode_string_sequence('(ノಠ痊ಠ)ノ彡┻━┻')# Chains of key pressesEG_COPY = KC.LCTL(KC.C)EG_PASTE = KC.LCTL(KC.V)# This is where we control what keys are sent when a switch is pressedkeyboard.keymap = [ [ KC.MPLY, EG_COPY, EG_PASTE, EG_STRING ]]# Below configures what happens when the encoder is turnedencoder_handler.map = (((KC.VOLD, KC.VOLU, None),),)# With everything configured, time to become a keyboard!if __name__ == '__main__': keyboard.go()Press the keys / turn the encoder on your keyboard and see if they all work. By default they will work as below. SW0 / Encoder: Media Play / Pause SW1: Copy SW2: Paste SW3: Prints the Linux Copypasta Encoder Clockwise: Volume Up Encoder Anticlockwise: Volume DownIf you have issues, check the diodes are installed in the correct orientation and all pins are soldered. Just incase you have issues with the diodes, there is a “no diode” IO configuration on line 21 that can be commented in to check if the diodes are the issue or if it exists somewhere else.Assuming everything is working, it’s time to jump to mechanical assembly and attach the base before returning here to configure the keyboard to send whatever keycodes you want. Below are a few links to KMK documentation to help guide you. There’s a reference of the available keycodes. International extension adds keys for non US layouts and Media Keys adds keys for … media.And to go even further: Sequences are used for sending multiple keystrokes in a single action. Layers can transform the whole way your keyboard is behaving with a single touch. ModTap allow you to customize the way a key behaves whether it is tapped or hold, and TapDance depending on the number of times it is pressed.If you make a change and notice your board is no longer working, there is a good chance there is a bug somewhere that is preventing the code from running. If this is the case, the onboard RGB LED will blink a error code that corresponds to the below. 1 GREEN blink: Code finished without error. 2 RED blinks: Code ended due to an exception. Check the serial console for details. 3 YELLOW blinks: CircuitPython is in safe mode. No user code was run. Check the serial console for safe mode reason.To check the serial console for details, you will need a tool like PuTTY, or Screen. You can also use Mu, which is the recommended editor for CircuitPython and has an inbuilt serial terminal.There are also some “challenge” problems here that I wrote for my FIRST Robotics team if you’d like examples of what is possible with the keyboard.Mechanical AssemblyWith the electronics done, it’s time to assemble the case. Check you have the below before continuing. 1 x Acrylic base 4 x M2 standoffs 8 x M2 bolts 4 x BumponsStart by removing the protective paper off the acrylic base.Grab a screw and standoff, and screw into one of the holes in the acrylic.Repeat for all four corners.Using a 1.5mm allen key, screw the PCB to the standoffs with the remaining screws.Finally, add the bumpons to four corners of the acrylic.Now it’s time to sit back and enjoy all of your hard work, as you’ve successfully assembled your new keyboard and can begin programming it.The EndWith all the above done, you should have a fully functioning keyboard whose function is only limited by your imagination (and the rules of physics). If you would like to learn more, the KiCad design files for the PCB can be found on Github, and the schematic can be downloaded here.Caught the soldering bug and want to buy some equipment for use at home? I have a suggested list here.If you have any questions or feedback please let me know, otherwise happy typing!" }, { "title": "Attempting to Build a Low Cost Vector Network Analyser", "url": "/vna/", "categories": "", "tags": "", "date": "2022-08-11 20:00:00 +1000", "snippet": "Originally posted 2019/11/18For my final year project, I set the rather ambitious goal of designing a low cost vector network analyser (VNA) which would preformant enough to deserve a spot on my be...", "content": "Originally posted 2019/11/18For my final year project, I set the rather ambitious goal of designing a low cost vector network analyser (VNA) which would preformant enough to deserve a spot on my bench. As you may have guessed by the title of this post, I ran into a few issues during the process which prevented the VNA from functioning well enough to be used on a day to day basis, however it was a very interesting project to work on.For those interested the full write up of the project along with all design files can be found on github (warning 25 MB pdf), however I’ll summarise the key points from the thesis below.ArchitectureWith the goal of the project to keep the price as low as possible, the design choices made at the architectural level played a key role in not only defining cost, but the function and accuracy of the device. The functional block diagram can be found below, with two key cost / performance drivers being the AD8302 gain and phase detector IC, along with the Mini Circuits ADC-15-4+ directional couplers.The AD8302 is an RFIC which takes two RF inputs and outputs two analog voltages proportional to the phase and voltage difference between the two inputs, and enabled a low cost micro controller to be utilised to determine the magnitude and phase response of the DUT, compared to using an ADC and a bunch of DSP on a FPGA or higher end micro controller to sample, calculate, and transmit the result. This route does have decreased dynamic range, however due to the directional couplers being utilised this was not a limiting factor in the design.One requirement I had set for the project was that all components must be COTS, as this made the design easier and cheaper to implement, with an obvious tradeoff in performance. The best directional couplers I was able to find for this project were from MiniCircuits with their ADC-15-4+, which had &gt; 24 dB of directivity over the specified frequency range, and I was even able to push them above the 1 GHz upper frequency bound whilst maintaining enough directivity to be useful for this device.Schematics can be found here for the VNA, along with the KiCad design files.PCB DesignAll of the above outlined components need somewhere to live, and four layers of FR4 in a signal/GND/3V3/signal configuration worked well for this application. OSHPark’s design rules were followed, as even though I would be ordering it from a Chinese board house due to my location in Australia, I wanted it to use standard processes which anyone would be able to recreate if the project was successful.Not only was this board the most complicated board I designed / laid out to date due to the number of parts and the RF design requirements, it was also one of the earlier boards that I had used 0402 passives, QFN components, and reflowed in my modified T962 oven, and as such required a bit of rework to get it powered up without any shorts.I was also fortunate that there only ended up being a small number of issues with the schematic / layout, with only one being critical as it was on the RF path which was easily resolved.Firmware / SoftwareThe firmware and software for the device were spit into two halves, with the STM32F373 on the VNA being responsible for low level hardware control and sending back frequency/magnitude/phase information, and Python running on a host computer to handle to user interface, do more complicated signal processing and calibration where NumPy and Scikit-rf were able to be utilised, along with proving display of the measured S parameters.As someone whose favourite programming language is solder, I took this project as a reason to force myself to do some low level programming, with all the firmware being developed in C using ST’s HAL by yours truly. Whilst this led to many hours writing and debugging low level functions such as the USB-serial interface or the command parser, along with the struggles of bringing the MAX2871 PLL up whilst never knowing if the issue was hardware or software (note: it was both) I’m now much more comfortable with lower level firmware development which will be useful going forwards.Performance and FunctionDue to a number of issue which resulted from lack of experience on my behalf, the performance of the VNA was ultimately unsatisfactory, with the phase measurement being near useless. Whilst I won’t go into the details (thesis contains all the juicy info if you are keen) it primarily came down to a few design decisions including poor filtering of the LO’s numerous harmonics due to the divided down output, strange behaviour of the AD8302 in certain conditions, and issues during calibration caused by a difference in dynamic range between the cal standards and measured values. The first two issues could have been found and resolved with testing during the development process which was not done due to a lack of time and access to resources, and the latter may have been an easy software fix, but was found with two weeks to go and there was not enough time to resolve it.With this said, in certain situations the VNA performs well enough to be useful, as can be seen below in comparisons between my design and a commercial Agilent VNA.ConclusionWith all of this said, the VNA is somewhat useful for measurements in the 433 and 915 MHz ISM bands if absolute accuracy is not crucial, however it won’t be replacing my desire to place a commercial VNA on by bench any time soon.It has however provided a very useful learning experience in a bunch of areas such as RF architecture, design, and layout, firmware development, and even mechanical design, and given that I had a whole three months of RF experience before beginning this project I’m happy that it functioned at all.What’s next? I still have few components laying around from the build so expect a small RF signal generator to make an appearance in the new year, however due to some fundamental issue with the design of the VNA I won’t be continuing it’s development any further." }, { "title": "RF Signal Generator", "url": "/rf-sig-gen/", "categories": "", "tags": "", "date": "2022-08-11 20:00:00 +1000", "snippet": "Originally posted 2020/05/17Following my build of a low cost vector network analyser last year, I had a desire to add to my RF lab, and with the parts I had remaining a simple RF signal generator s...", "content": "Originally posted 2020/05/17Following my build of a low cost vector network analyser last year, I had a desire to add to my RF lab, and with the parts I had remaining a simple RF signal generator seemed to be the obvious choice. The end result is shown above, and is capable of sweeping between 23.5 MHz and 6GHz, with -35 to +15 dBm of output power (-25 to +10 guaranteed).Whilst I had considered making it a single board device with the micro-controller on-board, due to the ubiquity of the Adafruit Feather form factor I decided to design this as a “Feather Wing” so it can be plugged into a number of different main boards, which would allow it to be used in conjunction with WiFi, BLE, or even Circuit Python, all by switching out the board it is plugged into and writing some new firmware.However, after struggling to get the MAX2871 up and running on my VNA for a number of reasons, all of which existed between the keyboard and chair, I wanted to be able to port as much of my firmware as possible over to whatever Feather I used. Whilst the STM32F405 Feather would have been a perfect option (as I used a STM32F373 on my VNA), it was not available when starting this project, so I designed a STM32F103 Feather, which with the exception of the ADC driver could run all of my previously developed VNA firmware.Another goal of this project was to write a GUI for it, as I ran out of time with the VNA and wanted to get some experience designing a user friendly interface for the device. After first writing a python script which handles proper argument parsing and error checking (both lacking in the firmware), I designed a GUI in PyQt5 which would call the python script, and would in turn send the correct commands to the signal generator over a COM port. Being the first real project I had used QT for there was plenty of learning experiences along the way, but the end result was quite nice, with a simple GUI allowing the frequency and power to be set, along with configuring a frequency sweep.What’s next for the signal generator? There are a number of features including Int/Frac-N PLL selection, power sweeping, and a few bugs with the CLI usage which need be added / resolved, however some of these will require a rewrite of the firmware to handle these options, as the code ported from the VNA was very narrow in scope. As it is I’ve been looking for a project to play around with an RTOS on, and this project would be perfect for this as there are a number of limitations due to the single threaded design of the current firmware. However after spending the last month and a bit getting the firmware and software working I need a break to design some hardware, so will continue this project at a later date. If you want to find out more about the project, look at the design files, or make your own, all of the info is up on GitHub. Feel free to reach out if there are any questions." }, { "title": "iCE40 Feather", "url": "/ice40-feather/", "categories": "", "tags": "", "date": "2022-08-11 20:00:00 +1000", "snippet": "iCE40 Feather is a Lattice iCE40UP5K FPGA in the Adafruit Feather form factor.Features Lattice iCE40UP5K FPGA. 20 IO in the standard Feather pinout. 6 extra IO on AREF and extra pads on back of ...", "content": "iCE40 Feather is a Lattice iCE40UP5K FPGA in the Adafruit Feather form factor.Features Lattice iCE40UP5K FPGA. 20 IO in the standard Feather pinout. 6 extra IO on AREF and extra pads on back of board. FT2232 enables both programming and communications over UART through a Type-C USB connector. QSPI flash. Onboard RX/TX, user, and RGB LEDs.Source files can be found on Github." }, { "title": "Entropy", "url": "/entropy/", "categories": "", "tags": "", "date": "2022-08-11 20:00:00 +1000", "snippet": "A 96% Southpaw keyboard, with split space, encoder, and wireless support.Entropy started as a STM32 powered keyboard running QMK and enclosed in a FR4 and PLA case, but has evolved into a nRF52 run...", "content": "A 96% Southpaw keyboard, with split space, encoder, and wireless support.Entropy started as a STM32 powered keyboard running QMK and enclosed in a FR4 and PLA case, but has evolved into a nRF52 running ZMK, tucked inside a stacked acrylic case.ZMK enables wireless functionality, and you’ll get upwards of 6 months battery life thanks to the 200uA sleep current.It also supports up to 4 rotary incoders in 5 different positions, along with a myriad of layout options.Source files can be found on Github." }, { "title": "ECP5 Mini", "url": "/ecp5-mini/", "categories": "", "tags": "", "date": "2022-08-11 20:00:00 +1000", "snippet": "ECP5 Mini is a Lattice ECP5 FPGA in the Black Mesa Labs “S7 Mini” form factor.Key Features Lattice ECP5-12/25F FPGA in a caBGA256 package. 32 / 64 3V3 IO on 2.54mm / 1.27mm pitch grid. 64 Mbit H...", "content": "ECP5 Mini is a Lattice ECP5 FPGA in the Black Mesa Labs “S7 Mini” form factor.Key Features Lattice ECP5-12/25F FPGA in a caBGA256 package. 32 / 64 3V3 IO on 2.54mm / 1.27mm pitch grid. 64 Mbit HyperRAM DRAM. USB Full Speed (12Mbit) connection to FPGA over Type-C connector. MicroSD card support. 8 Multiplexed RGB LEDs. USB dfu bootloader courtesy of tnt.Source files can be found on Github." }, { "title": "Sea-Micro", "url": "/sea-micro/", "categories": "", "tags": "", "date": "2022-08-04 20:00:00 +1000", "snippet": "An Arduino Pro Micro, with but with a Type-C connector.Targeted as an alternative for the ubiquitous Pro Micro in DIY keyboard applications.Features: Pro Micro compatible pinout. Mid Mount USB Ty...", "content": "An Arduino Pro Micro, with but with a Type-C connector.Targeted as an alternative for the ubiquitous Pro Micro in DIY keyboard applications.Features: Pro Micro compatible pinout. Mid Mount USB Type-C Connector. On-board reset button.Developed in conjunction with Custom KBD.Source files can be found on Github." }, { "title": "Louise", "url": "/louise/", "categories": "", "tags": "", "date": "2022-08-04 20:00:00 +1000", "snippet": "A project between Josh and RiotPunch to build a 75% alice keyboard with a southpaw numpad.Running on a STM32 microcontroller, it has support for both normal and flipped numpad layouts, various lowe...", "content": "A project between Josh and RiotPunch to build a 75% alice keyboard with a southpaw numpad.Running on a STM32 microcontroller, it has support for both normal and flipped numpad layouts, various lower row combinations, and underglow RGB.Thanks to Warmthoughts for the photo.DocumentationAll design files are available on Github.The release tab contains the qmk source files, VIA JSON, along with a VIAL precompiled binary.Boards work with VIAL, head to vial.rocks or download their configurator to remap the board.There are 4 status LEDs above the F5 - F8 keys that can be configured in the source code - not in VIAL.By default LED 1 is a capslock LED, and LED 2 is an active low numlock LED." }, { "title": "Hub20", "url": "/hub20/", "categories": "", "tags": "", "date": "2022-08-04 20:00:00 +1000", "snippet": "Hub20 is a numpad with a bunch of features you never knew you needed. They include: Left and Right handed layouts supported, along with a 4x5 1U grid enabling it to be used as a macropad. Two rot...", "content": "Hub20 is a numpad with a bunch of features you never knew you needed. They include: Left and Right handed layouts supported, along with a 4x5 1U grid enabling it to be used as a macropad. Two rotary encoders, enabling intuitive controls for a wide range of tools including CAD and photo / video editing. Inbuilt USB 2.0 Hub with Type-C connectors, allowing connection to other keyboards, memory sticks, wireless receivers and more! VIA and QMK compatibility, including a “macro” mode enabling the keys to be remapped on a host computer. 27 addressable RGB leds, including one under each key.If this project looks familiar, it’s because it contains all the best parts of Hub16, with a few added extras.Hub20 is available for purchase on Tindie.For the getting started guide, documentation, and design files, please visit the Hub20 Github repo." }, { "title": "Hub16", "url": "/hub16/", "categories": "", "tags": "", "date": "2022-08-04 20:00:00 +1000", "snippet": "Hub16 is a macropad with a bunch of features you never knew you needed. They include: 16 Cherry MX compatible keys, along with switches in each encoder. Two rotary encoders, enabling intuitive co...", "content": "Hub16 is a macropad with a bunch of features you never knew you needed. They include: 16 Cherry MX compatible keys, along with switches in each encoder. Two rotary encoders, enabling intuitive controls for a wide range of tools including CAD and photo / video editing. Inbuilt USB 2.0 Hub with Type-C connectors, allowing connection to other keyboards, memory sticks, wireless receivers and more! VIA and QMK compatibility, including a “macro” mode enabling the keys to be dynamically remapped on a host computer. 11 addressable RGB LEDs to display state, or just light your desk up.Hub16 is available for purchase on Tindie.For the getting started guide, documentation, and design files, please visit the Hub16 Github repo." }, { "title": "Sea-Picro", "url": "/sea-picro/", "categories": "", "tags": "", "date": "2022-08-03 20:00:00 +1000", "snippet": "Sea-Picro is a RP2040 based board in the Arduino Pro Micro form factor. Like Sea-Micro, its designed to be a drop in replacement for keyboards wanting an upgrade from ATmega32u4 based pro micros.Th...", "content": "Sea-Picro is a RP2040 based board in the Arduino Pro Micro form factor. Like Sea-Micro, its designed to be a drop in replacement for keyboards wanting an upgrade from ATmega32u4 based pro micros.There are two variants: EXT, featuring an Elite-C pinout, with dedicated 5V RGB LED pin, but without a reset button. RST, featuring a pro micro pinout, with onboard RGB LED and reset button.Sea-Picro can be purchased from CustomKBD.Sea-Picro EXTSea-Picro RSTFeatures Compatiable with most pro micro based keyboards RP2040 microcontroller, with dual M0+ processors at up to 133MHz Mid mount USB-C connector, which is low profile and can’t be ripped off Optional Elite-C style pinout, adding an additional 5 IO for large keyboards Single button reset / bootloader circuit which changes behavior based on how long it’s held (RP2040 usually requires two buttons to flash new firmware, making it challenging when installed upside down in a keyboard) ROM bootloader which prevents board from being bricked EXT version has a 5V level shifter and extra pin to drive strings of WS2812 LEDs. RST version has a WS2812 LED for use with CircuitPython or as a status indicator on the RST version. Onboard power LED. IO pinout identical to the Sparkfun RP2040 Pro MicroPinoutSource files can be found on Github.DocumentationSea-Picro can work with most existing Pro-Micro compatible keyboards on the market, you just need to recompile the firmware to suit Sea-Picro first. You cannot use an existing .hex file.To do this, we can use converters in QMK to remap the pins to suit Sea-Picro.As Sea-Picro has the same pinout as the RP2040 Pro Micro, we can use the promicro_rp2040 converter to remap the pins. An example for Chalice is shown below:qmk flash -c -kb chalice -km default -e CONVERT_TO=promicro_rp2040Due to the SPI flash chip used on Sea-Picro, you may need to add #define RP2040_FLASH_GD25Q64CS to your config.h file.You can also build the keymap from scratch following these instructions.Reset / Bootloader ControlDue to how the RP2040 microcontroller on Sea-Picro functions, the reset button behaves differently to traditional Pro Micro based controllers. Tapping the reset button for &lt; 500ms will cause the board to reset and your code to start running again. Holding the reset button for &gt; 1 second will cause the board to go into bootloader mode and allow you to flash new code.QMK has added a “double tap for bootloader” feature for RP2040 boards, however due to the implementation on Sea-Picro this may not work and it’s suggested to hold the reset button to get into bootloader mode.FlashingFlashing Sea-Picro is a simple process. Compile your code as outlined above. Place the board into bootloader by holding the RESET button or using the QK_BOOT keycode. Once a drive called RPI-RP2 is detected, drag the .uf2 file generated by QMK onto the drive. The RPI-RP2 drive will disappear and a few seconds later your keyboard will be ready for use.CircuitPython FirmwareThe CircuitPython UF2 that ships with Sea-Picro can be found here if you need to restore it.Dedicated 5V RGB PinDue to the RP2040 microcontroller powering Sea-Picro running at 3.3V, it may not be able to drive the 5V addressable LEDs found on many keyboards. As such is has a dedicated 5V RGB output pin which will drive the LEDs at the correct voltage to ensure smooth operation.If you run into issues driving the LEDs (e.g. glitching, incorrect colours being shown) consider changing the RGB_DI_PIN to 25 in your keyboards conf.h file and running a wire from the 5V RGB pin to the first LED in the chain.KiCad LibraryIf you’d like to use Sea-Picro in your next keyboard, please download the KiCad Library which contains symbols, footprints, and 3d models for Sea-Picro.KMK / CircuitPython UsageIf you’d like to use Sea-Picro with KMK or CircuitPython, Sea-Picro is flashed with a CircuitPython bootloader out of the box, and to get KMK up and running is simple. Download a copy of KMK. Unzip it and copy the KMK folder and the boot.py file to the root of the USB drive CIRCUITPY. Unplug and replug your device to force the boot.py changes to be implemented. Open the existing code.py file on the CIRCUITPY drive with a text editor and add the below code.print(\"Starting\")import boardfrom kmk.kmk_keyboard import KMKKeyboardfrom kmk.keys import KCfrom kmk.scanners import DiodeOrientationkeyboard = KMKKeyboard()keyboard.col_pins = (board.GP0,)keyboard.row_pins = (board.GP1,)keyboard.diode_orientation = DiodeOrientation.COL2ROWkeyboard.keymap = [ [KC.A,]]if __name__ == '__main__': keyboard.go()Shorting the 0 and 1 pins on Sea-Pico should then type a, and you can begin configuring the board.For more info on using KMK, please see their getting started guide." } ]
